Sidney Jackson & Florian Pontani
sjacks85@jhu.edu flo@jhu.edu
Last Modified: October 27, 2015

READ_ME FILE:
*****************************
SUMMARY:
**We should probably consider making a menu for the driver at some point.**

***Critter Class: 

Basically a class containing the characters of the critter (scary, cute,
strange),  along with the critter data (which we will use maps
to interpret the characteristics… which will be printed to the user
of the program and be accompanied with the feature/parts of the creature).

Also! This class needs an overloaded decode function that is capable of
calling he decode function from the feature classes.

***Feature Classes:
 
Feature Details:
Features:

Feature 1: Covering
Feature 2: Eyes
Feature 3: Limbs
Feature 4: Digits

Pssible Future Implementation:

Feature 5: Shape
Feature 6: Personality

There should also be an encode function and a decode function for 
encoding/decoding the binary “DNA”.

Each feature class needs an encode function and a decode function. The encode
function will, in a sense, create an "array" of bits that 
will later be decoded. This "array" of bits define each have a particular
bit length associated with them and define the characteristics. 

We will then need a decode function that will interpret this into numbers
that define the characters.

We'll need to use bit shift operators to get to the characeristics we 
want. (Example: If the "limb" of the critter is defined with 4 bits and
can be found 15 bits into our DNA "array" of bits, we'll need to bit shift
by 15 and start reading after bit 15 for 4 bits. Then we decode those 4 bits
(say it's 0101) into "5". Then we give the critter whatever "limb" attribute
is associated with "5". Let's say, 5 = Short. The critter has short legs.
This is basically how all features will be defined and decoded.)

Binary Encoding: This is a lot more ideal for working with pseudo genetics 
which involve mutations (flipping bits) and also carrying out pseudo-cross
over that is so integral to genetics regarding critter reproduction anyway.

Encoding Class:
Has the Cross-Over Function.
Has the Mutation Function.

Decoding Class:
Decoding function:
Decodes binary into appropriate numbers.
Mostly just interprets binary using functions that can tell where they
need to look to get what it needs to get. This will particularly important to
creating human readable strings. No matter what new feature we add,
we can finesse it into a cohesive, human, readable string as long as we place
the descriptor derived from the binary code into a grammatically sensible 
paragraph describing each critter.

This suggests that each feature will also need to know where to look when
trying to find its descriptors along the DNA string (the very long
integer).

Issues/Frustration:
Not entirely sure how to turn each individual feature characteristic
into one cohesive binary string. Reference offsets inside and outside of 
the code are needed. Found it difficult to "concatonate" binary strings
not related to each other. Binary math needed???

Overall Outcome:
Not there yet...

ASSIGNMENT FEEDBACK:
Not there yet...

NOTES:

Driver Class:
Include Menu:
Functions in Menu:
Create (Random) Critter (No argument)
Name Critter (User Input String)
Make Crtter (Critter_1, Critter 2)
List Critters (No argument)
Describe Critter (Critter_1)

Encoding:
int [FEATURE] type
static map <int, string> 
type String
"0" - type_1
"1" - type_2
"2" - type_3
"3" - type_4

Convert associated number into a binary value.
-> Where encoding (genome) class comes in.
(Interprets bit strings)

Example:
/*To make defining type simpler*/

typedef unsigned long encoding_type

class encoding {
	public:

	setBitField(unsigned offset, unsigned width, unsigned value);
	unsigned ing getBitField(unsigned int offset, unsigned width) const;
	/*Convert number to binary string*/
	/*Also, probs a regular string of decimal numbers too*/

	void mutate(double mutateRate = 0.05);
	Encoding crossOver(const Encoding &other, double crossoverRate = 0.1);

	
	private:
	   encoding_type;
}

Questions: 

How do we account for the offset/width?
How do we account for the offset "dynamically"?

